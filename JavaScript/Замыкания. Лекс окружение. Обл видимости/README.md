# !!! Содержание данного MD файла не охватывает полностью все материалы, представленные в .docx документе и .js файле. Этот MD файл предназначен исключительно для ознакомления и не содержит полного объема информации !!!

# СОДЕРЖАНИЕ

1. [Лексическое окружение](#1-лексическое-окружение)
2. [Замыкания](#2-замыкания)
3. [Разбор первой задачи](#3-разбор-первой-задачи)
4. [Область видимости](#4-область-видимости)
5. [Какие недостатки имеет VAR](#5-какие-недостатки-имеет-var)

## 1. Лексическое окружение

Лексическое окружение — это некоторый невидимый (скрытый) объект, который есть у любого блока, скрипта или функции в JavaScript.

Данный объект состоит из двух частей:

- Объект с переменными текущей области видимости,
- Ссылка на внешнее родительское лексическое окружение.

Рисунок 1 – Лексическое окружение.

Разберем примеры:

Рисунок 2 – Пример лексического окружения.
1 глобальное имеет доступ только к своим переменным.
2 локальное имеет доступ ко всем переменным. Будет создано только во время вызова ф-ции.

## 2. Замыкания

Замыкания — это способность ф-ции в JS запоминать лексическое окружение, в котором она была создана. Т.е. хранить в себе ссылку на это окружение.

Рисунок 3 – Замыкания.
Происходит поиск переменной x, тк в текущем лексическом окружении ее нет, ф-ция смотрит на родительское окружение, это и есть замыкание.

## 3. Разбор первой задачи.

Рисунок 4 – Разбор задачи
И так, как будет выполняться этот код и как будут созданы окружения? Сначала создает глобальное лексическое окружение:

Далее в него добавляется makeCounter: function и происходит первый вызов этой функции, в качестве аргумента передаем 0.
Так вот при вызове этой функции, мы попадаем внутрь функции makeCounter, на этом этапе создается новое лексическое окружение для этой функции и в него добавляется переменная count: 0:

Результат сохраняется в переменной counter и попадает в глобальное лексическое окружение, то же самое со второй.
И так сейчас мы имеет такую картину:

Лексическое окружение для первого вызова и для второго вызова это совершенно разные независимые объекты.
Далее вызываем функцию counter(), что происходит в этот момент? Мы попадаем внутрь функции, которую вернули до этого, то есть на строку 5. Для этого вызова функции также создается свое лексическое окружение:

Но в нем нет лексического окружения, оно пустое, чтобы выполнить count++ мы пытаемся найти переменную и не находим ее в нашем лексическом окружении, поэтому мы обращаемся к родительскому окружению и там находим count, которая равна 0.
Далее мы возвращаем ее и только ПОСЛЕ return прибавляем один. Поэтому первый лог выведет ноль:

Теперь там count уже равен 1. Далее происходит еще один вызов, и происходит все то же самое, не находим в новом лексическом окружении count, идем выше, находим его там и там оно равно уже 1, мы его возвращаем и только потом прибавляем один.

## 4. Область видимости

Область видимости переменных:

- Глобальная: доступна во всем файле.
- Функциональная: доступна только внутри функции.
- Блочная: доступна внутри блока с {} скобками.

## 5. Какие недостатки имеет VAR

Недостатки VAR:

- Переменная имеет функциональную область видимости.
- Возможность переопределения и переобъявления переменной.
- Возможность использования переменной перед ее объявлением.
- Создает свойство в глобальном объекте window.
